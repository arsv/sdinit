Notes on sninit design
~~~~~~~~~~~~~~~~~~~~~
This file lists some design considerations that were put into sninit,
and some choices made when there were several alternatives.

It is not intended for general users, but it may be helpful
for those trying to extend sninit, or perhaps just to read the source.


On initrecs
~~~~~~~~~~~
Initrec is an "init record", corresponding to one line in inittab
(process-describing line that is) or a single file in an initdir.
In the code it is called struct initrec.
Each initrec holds at most one pid.

Throughout the code, initrecs are classified as w, o and s type:

				respawn		exclusive
	s	service		yes		no
	w	wait		no		yes
	o	once		no		no

Respawn determines how init should react when process dies
"unexpectedly", as opposed to being killed by init.
Exclusive means should not start anything else while this
particular process is running.


Same uniform list for w/o- and s-type initrecs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sninit keeps all initrecs in the same list, using the same initrec structures,
and has to loop through all of them even while sitting in a single runlevel.

The alternative is to keep a list of s-type records separately,
and only check for w- and o-type records when switching runlevels.

There is no clear answer here, not for me at least, but uniform
list is clearly simpler and the price (both cpu and mem) looks negligible.
One clear advantage of uniform list is that it allows starting some
services before performing w-type tasks:

	mount::w:/bin/mount -a
	syslog:::/sbin/syslogd
	kbd::o:/sbin/setkeys ...
	net::o:setup-network ...

and so on. This way, syslogd will have a chance to come up before anything
significant takes place, and thus to save some messages that otherwise could
have been lost.

Note: will have _a_chance_ to come up.
Trying to make sure syslogd is up and running is a bad idea in my opinion;
see dependencies.txt .


telinit communication
~~~~~~~~~~~~~~~~~~~~~
Originally telinit used /dev/initctl pipe, just like sysvinit.
The pipe was subsequently replaced with a stream-oriented unix
domain socket (UDS) from the abstract namespace (see unix(7)).

UDS provide two-way communication, allowing error messages and
status reports to be passed back to telinit. Without this, it
would be "telinit q and go check syslog for results".
An alternative was using two pipes, an extremely ungraceful solution.

Stream UDS are connected, and thus automatically solve possible races
with two telinits calling sninit at the same time.

Abstract namespaces impose no dependencies on /dev filesystem.
Which happens to be really handy when it's unclear whether you'll have
a read-only space there, or a kernel-mounted ramfs with no static files.


Linux-specific features
~~~~~~~~~~~~~~~~~~~~~~~
reboot(2), getdents(2), abstract namespace for UDS etc. are not portable.

If one needs sninit for BSD, one can take it and make a BSD-specific version;
a lesser evil than having code cluttered with #ifdef's in what ultimately
is a very system-specific utility.


sninit does not discard startup entries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Both sysvinit and busybox init can drop entries that are only used to
bring the system up (=to switch from runlevel 0 to some other runlevel).

It is possible for sninit, too, but more difficult due to different memory
allocation model. And if implemented, it will probably consume more space
in the code than it will save in data.

One clear way to do it is to mimic reconfiguration, copying cfgblock
to newblock while filtering out entries not needed anymore.

Another option is moving initrecs within cfgblock.
This currently requires both tricky pointer work, and initrec length field.
Or dropping pointers altogether and using offsets only, but this approach
has its own drawbacks.


The lack of console initialization in setup()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sninit uses whatever it has got on fds 0, 1, 2.
sysvinit does set some tty parameters, however, I see no good
explanation for why this is necessary.
My opinion is that the kernel knows better.

Initial console can very well be serial, the kernel probably set it up,
no need to touch anything there.

Daemons and startup scripts should be told to use /var/log or syslog
instead of stderr (if not, let them use whatever the kernel
provided to sninit). getty does console init on its own.


Running parallel chains
~~~~~~~~~~~~~~~~~~~~~~~
As in
	(p1; p2; p3) &
	(p4; p5; p6) &
and waiting for them to finish.
Currently sninit only allows this by putting "p1; p2; p3" in a shell script,
"p4; p5; p6" in another script and running the scripts as o-type entries.

I can't see a simple solution here, so it's left unimplemented for now.


systemd-style dependencies
~~~~~~~~~~~~~~~~~~~~~~~~~~
Abandoned completely. See dependencies.txt.


(...) respawns too fast, disabled for 5 minutes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sninit has uniform, reasonably low timeouts between spawning attempts.

The only reason to have these timeouts in the first place
is to avoid consuming too much resources (cpu and possibly syslog)
for a specific process that just fails to start.
My opinion is that something like a couple of seconds is enough
for this, CPU-wise at least. Syslog may need some more care.

Measuring the time between spawn() calls, instead of the time
between SIGCHLD and spawn(), means the first attempt to restart
the process will occur immediately after it dies (assuming it
was alive for more than the timeout value), but further attempts
will be suspended. Makes more sense to me than sysvinit's idea of
doing several fast respawns, then pausing for the whole 5 minutes.


Services are s-type only
~~~~~~~~~~~~~~~~~~~~~~~~
Entries read from service files are assumed to be s-type only.
This is mostly because I can't think of any good scenario
involving non-s-type service files.

Service files are needed to simplify daemon installation.
I.e. a package puts its file to /etc/rc and that's it.
Installing something related to system initialization this
way looks like a really bad idea to me.
Also, since directories are inherently unordered, w-type entries
wouldn't make much sense anyway.

Possible application of non-s-type service files:
a file containing loadkeys is an r-type service file
owned by kbd package.


Service shell scripts
~~~~~~~~~~~~~~~~~~~~~
That is, special handling for service file starting with #!.
It was easy to implement, it didn't take much code space,
and it provides a usable way for chaining w-type actions before
a daemon s-entry.
A typical problem,

	test -d /var/cache/squid && mkdir -p /var/cache/squid
	exec squid

would require really ugly workaround without this.

Makes ps output clearer, too.

An alternative was to pipe the file contents to the interpreter, i.e.

	#:345:log:/bin/sh -
	test -d /var/cache/squid && mkdir -p /var/cache/squid
	exec squid
	
This partly duplicates #! functionality, and requires sninit to store
the whole file in initrec.

In a way, storing the script in initrec IS implemented, since the following
will work by passing the whole script as argument to sh -c:

	#:345:log:!
	test -d /var/cache/squid && mkdir -p /var/cache/squid
	exec squid

However the point is that it's not the only alternative.
If one needs, one can use proper shell scripts.


Builtins
~~~~~~~~
That is, bundling some commands with init, busybox-style. Or, perhaps, sh style.
Actually, there are two points here:
	1. telinit as a link to init, and
	2. ":123:wait:run -u nobody daemon" with "run" being a part of init
Both were abandoned, for now at least.

#1, telinit is much more independent from init than it is in sysvinit, due to lack
of state passing. Otherwise there are no clear reasons to bundle them, so it was
decided to keep them separate.

#2, the list of builtins could have included telinit (or "fast telinit", without the need
to exec anything), but the main reason why this may be needed is implementing euid, egid
and ulimit setting. This stuff must be done in the child process, and e[ug]id requires reading
additional passwd and group, which is not something init needs.

This was abandoned completely in favor of companion utility, see limits.txt.


Runlevels and flags
~~~~~~~~~~~~~~~~~~~
The 2nd and 3rd fields in an init line describe essentially the same things.
Runlevels, the 2nd field, uses one-letter keys while the 3rd field uses comma-separated
words. It makes a lots of sense to merge them, leaving a single field containing a mix
of flags and runlevels.

This idea was abandoned for several reasons:
1. separate runlevels field allows an empty value as a shorthand for ^0
2. when mixing one-digit and one-word keys, some kind of separator between them is still
   needed, and ":" works just as well as any other separator.
3. more complicated syntax for the flags field was planned, and that would not mix well
   with one-digit runlevels
4. on-demand runlevels do not mix well flags


Current runlevel in argv[0]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
That is, making ps output look like "init 3" instead of "/sbin/init".
Sysvinit has this feature. It's easy to implement, too.

Still I can't find any reason why this may be useful. Especially in sysvinit.

For those extremely rare occasions when it's needed, telinit ? provides the answer.
