Generic instructions
~~~~~~~~~~~~~~~~~~~~
Check config.mk and/or config.h for build-time setup.
Specifically, check INITCTL, INITTAB, LOGDIR in config.h,
compiler setup and installation directories in config.mk.

Run make, then make install.

Alternatively, run mostly-autotools-compatible configure.

To try it on a system with another init installed, run

	configure --with-s

You will get sinit, stelinit and /etc/sinittab.


Cross-compiling
~~~~~~~~~~~~~~~
Set CC and AR in config.mk for your target architecture.
Alternatively, run configure --target=(toolchain-prefix).

sninit follows Linux kernel naming scheme, with CC for target executables
and HOSTCC for build system executables.


Which libc to use
~~~~~~~~~~~~~~~~~
In most cases sninit should be built with dietlibc.

sninit does not need dynamic libc, and will not benefit from using one.
The smallest sninit executable is the one linked statically against dietlibc.

sninit also does not need anything other than basic syscalls and a handful
of bog-standard string manipulation function from libc.
It will not benefit from using anything fancier than dietlibc.

Settings for other libc-s are only provided for completeness,
for testing, and for unusual cases not considered here.


Building with bundled libc
~~~~~~~~~~~~~~~~~~~~~~~~~~
sninit comes with a stripped-down, minimalistic subset of dietlibc
capable just enough to fit sninit demands.
Sample usage (cross-build for mips):

	ARCH = mips
	CC = mipsel-linux-gnu-gcc -march=mips2

CC will be called with -nostdinc -nostdlib so it does not matter
which libc, if any, it has in its sysroot.

Check libc/ subdirectories to see which architectures are supported
by bundled libc. For unsupported architectures, fall back to dietlibc
or perhaps system libc.

Using bundled libc provides little benefit over properly configured
dietlibc in terms of executable size (because it *is* dietlibc,
if perhaps re-written in some places) but instead gives clear,
uncluttered libc code for debugging.

Note "properly configured". Depending on target architecture,
default dietlibc configuration may add several kB of bloat.
See doc/dietlibc.txt


Building with dietlibc
~~~~~~~~~~~~~~~~~~~~~~
Recommended settings:
	CC = diet gcc
or
	CC = diet clang

Dietlibc up to and including 0.33 does not provide ppoll(2) system call.
Either use sys_ppoll.c (indirect syscall, via syscall(2)), or patch dietlibc.
Note syscall(2) is in libcompat.a, so you'll need
	LIBS = -lcompat

Because dietlibc implies static linkage and small executable size, consider using
sys_printf.c and sys_strerror.c. See comments in those files.
Size optimization (-Os) helps in most cases.
Link-time optimization (-flto) may or may not help, check for yourself.


Building with musl
~~~~~~~~~~~~~~~~~~
Use CC = musl-gcc; no other settings should be necessary.

If musl-gcc complains about linux/*.h, you probably have no linux headers in musl-gcc path.
Symlink /usr/include/linux and /usr/include/asm to resp. $MUSL/include/linux
and $MUSL/include/asm.


Building with glibc or uClibc
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Both glibc and uclibc lack getdents(2), even thought it is a linux system call.
Use sys_getdents.c instead.


Rebuilding
~~~~~~~~~~
Run "make archclean" before rebuilding with a different ARCH value
or with a different libc type. Those affect config.mk, and Makefile
does not track dependencies on config.mk

Regular "make clean" should be enough for any changes in config.h alone.

Use "make distclean" to remove all generated files including target executable.
Note however that config.h and config.mk are modified in place, there are no
autoconf-style config.h.in or config.mk.in, so distclean will not restore those.
